
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown and Mermaid to DOCX - Combined Editor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: sans-serif; 
            background-color: #f4f4f4; 
            height: 100vh;
            overflow: hidden;
        }
        .container { 
            background-color: #fff; 
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* 顶部工具栏 */
        .toolbar {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .toolbar h1 {
            font-size: 18px;
            margin: 0;
            color: #333;
        }
        
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* GitHub 链接样式 */
        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background-color: #24292e;
            color: #fff;
            text-decoration: none;
            border-radius: 4px;
            font-size: 13px;
            transition: background-color 0.2s;
        }
        
        .github-link:hover {
            background-color: #0366d6;
        }
        
        .github-link svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
        
        .star-button {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            background-color: #fafbfc;
            color: #24292e;
            border: 1px solid #e1e4e8;
            text-decoration: none;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .star-button:hover {
            background-color: #f3f4f6;
            border-color: #d1d5da;
        }
        
        .star-button svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        /* 编辑器和预览区域的容器 */
        .editor-preview-container {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex: 1;
            overflow: hidden;
        }
        
        /* 在屏幕宽度足够时，使用左右布局 */
        @media (min-width: 1024px) {
            .editor-preview-container {
                flex-direction: row;
            }
            
            .editor-wrapper,
            .preview-wrapper {
                flex: 1;
                min-width: 0;
            }
        }
        
        .editor-wrapper,
        .preview-wrapper {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .section-header {
            padding: 8px 15px;
            background-color: #e9ecef;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            flex-shrink: 0;
        }

        textarea#combinedContentInput {
            width: 100%;
            flex: 1;
            padding: 15px;
            border: none;
            border-right: 1px solid #ddd;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            overflow-y: auto;
            box-sizing: border-box;
            background-color: #fff;
        }
        
        textarea#combinedContentInput:focus {
            outline: none;
        }

        button { 
            padding: 6px 12px; 
            background-color: #007bff; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 13px;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #status { 
            font-style: italic; 
            color: #555; 
            font-size: 12px;
            margin-left: auto;
        }
        .error-message { 
            color: red; 
            font-family: monospace; 
            white-space: pre-wrap; 
            text-align: left; 
            background-color: #ffebeb; 
            border: 1px solid #ffc0c0; 
            padding: 10px; 
            margin: 5px;
        }
        label { 
            margin-right: 5px; 
            font-size: 13px;
            color: #495057;
        }
        select { 
            padding: 4px 8px; 
            border-radius: 4px; 
            border: 1px solid #ccc; 
            font-size: 13px;
            background-color: white;
        }

        #documentPreview {
            padding: 15px;
            border: none;
            background-color: #f9f9f9;
            flex: 1;
            line-height: 1.6;
            overflow-y: auto;
            box-sizing: border-box;
        }
        #documentPreview .markdown-preview-segment h1 { font-size: 18pt; font-weight: bold; }
        #documentPreview .markdown-preview-segment h2 { font-size: 14pt; font-weight: bold; }
        #documentPreview .markdown-preview-segment h3 { font-size: 12pt; font-weight: bold; }
        #documentPreview .markdown-preview-segment h4 { font-size: 12pt; font-style: italic; font-weight: normal; }
        #documentPreview .markdown-preview-segment h5,
        #documentPreview .markdown-preview-segment h6 {
            margin-top: 0.8em; margin-bottom: 0.4em; line-height: 1.2; font-weight: bold;
        }
        #documentPreview .markdown-preview-segment p,
        #documentPreview .markdown-preview-segment li,
        #documentPreview .markdown-preview-segment td,
        #documentPreview .markdown-preview-segment th {
             font-size: 10pt;
        }
        #documentPreview .markdown-preview-segment code { /* Inline code preview */
            font-family: monospace;
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
        }
        #documentPreview .markdown-preview-segment pre code { /* Code block preview */
            display: block;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            white-space: pre-wrap; /* Ensure wrapping in preview */
        }
        #documentPreview .markdown-preview-segment table {
            border-collapse: collapse;
            margin-bottom: 1em;
            width: auto; /* Or width: 100% if you want full-width tables */
        }
        #documentPreview .markdown-preview-segment th,
        #documentPreview .markdown-preview-segment td {
            border: 1px solid #ccc;
            padding: 6px 10px;
            text-align: left;
        }
        #documentPreview .markdown-preview-segment th {
            background-color: #f0f0f0;
            font-weight: bold;
        }
         #documentPreview .markdown-preview-segment hr {
            border: 0;
            border-top: 1px solid #ccc;
            margin: 1em 0;
        }


        #documentPreview .mermaid-preview-segment svg {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            display: block;
            margin: 15px auto;
            background-color: white;
            padding: 10px;
            box-sizing: border-box;
        }

        @media print {
            body * { visibility: hidden; }
            #documentPreview, #documentPreview * { visibility: visible; }
            #documentPreview {
                position: absolute; left: 0; top: 0; width: 100%;
                margin: 0; padding: 15mm; /* Typical print margin */
                border: none; box-shadow: none; background-color: white;
                font-size: 10pt;
            }
            #documentPreview button, #documentPreview input, #documentPreview textarea, #documentPreview select { display: none !important; }
            #documentPreview .error-message { border: 1px solid #666 !important; background-color: #f0f0f0 !important; color: black !important; }
            #documentPreview .mermaid-preview-segment svg {
                max-width: 100% !important; /* Try to fit within print area */
                width: auto !important; /* Allow shrinking */
                height: auto !important;
                page-break-inside: avoid;
                padding: 0 !important; /* Remove padding for print to maximize diagram size */
                border: none !important; /* Remove border for cleaner print */
            }
             #documentPreview .markdown-preview-segment h1 { font-size: 18pt !important; font-weight: bold !important; }
             #documentPreview .markdown-preview-segment h2 { font-size: 14pt !important; font-weight: bold !important; }
             #documentPreview .markdown-preview-segment h3 { font-size: 12pt !important; font-weight: bold !important; }
             #documentPreview .markdown-preview-segment h4 { font-size: 12pt !important; font-style: italic !important; font-weight: normal !important; }
             #documentPreview .markdown-preview-segment p,
             #documentPreview .markdown-preview-segment li,
             #documentPreview .markdown-preview-segment td,
             #documentPreview .markdown-preview-segment th { font-size: 10pt !important; }
             #documentPreview .markdown-preview-segment table { width: 100% !important; page-break-inside: avoid; }
             #documentPreview .markdown-preview-segment hr { border-top: 1px solid #000 !important; }
        }
    </style>
    <!-- 使用国内可用的 CDN 源 -->
    <script src="https://unpkg.com/mermaid@11.6.0/dist/mermaid.min.js"></script>
    <script src="https://unpkg.com/marked@15.0.12/marked.min.js"></script>
    <script src="https://unpkg.com/docx@9.5.0/dist/index.iife.js"></script>
    <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
</head>
<body>

    <div class="container">
        <div class="toolbar">
            <h1 data-i18n="title">Markdown & Mermaid to DOCX</h1>
            
            <div class="toolbar-group">
                <a href="https://github.com/xlight/md-mermaid-toDocx" target="_blank" class="github-link" title="View on GitHub">
                    <svg viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    <span data-i18n="viewOnGithub">GitHub</span>
                </a>
                <a href="https://github.com/xlight/md-mermaid-toDocx" target="_blank" class="star-button" title="Star this project">
                    <svg viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 .25a.75.75 0 01.673.418l1.882 3.815 4.21.612a.75.75 0 01.416 1.279l-3.046 2.97.719 4.192a.75.75 0 01-1.088.791L8 12.347l-3.766 1.98a.75.75 0 01-1.088-.79l.72-4.194L.818 6.374a.75.75 0 01.416-1.28l4.21-.611L7.327.668A.75.75 0 018 .25z"></path>
                    </svg>
                    <span data-i18n="starButton">Star</span>
                </a>
            </div>
            
            <div class="toolbar-group">
                <label for="fontPicker" data-i18n="fontLabel">字体:</label>
                <select id="fontPicker">
                    <optgroup data-i18n="chineseFonts" label="中文字体">
                        <option value="Microsoft YaHei" selected>微软雅黑 (Microsoft YaHei)</option>
                        <option value="SimSun">宋体 (SimSun)</option>
                        <option value="SimHei">黑体 (SimHei)</option>
                        <option value="KaiTi">楷体 (KaiTi)</option>
                        <option value="FangSong">仿宋 (FangSong)</option>
                        <option value="STSong">华文宋体 (STSong)</option>
                        <option value="STHeiti">华文黑体 (STHeiti)</option>
                        <option value="STKaiti">华文楷体 (STKaiti)</option>
                        <option value="STFangsong">华文仿宋 (STFangsong)</option>
                        <option value="NSimSun">新宋体 (NSimSun)</option>
                        <option value="PingFang SC">苹方 (PingFang SC)</option>
                        <option value="Heiti SC">黑体-简 (Heiti SC)</option>
                        <option value="STXihei">华文细黑 (STXihei)</option>
                    </optgroup>
                    <optgroup data-i18n="englishFonts" label="英文字体">
                        <option value="Calibri">Calibri</option>
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Tahoma">Tahoma</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Aptos">Aptos</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="toolbar-group">
                <button id="generateDocxButton" data-i18n="generateButton">生成 DOCX</button>
                <button id="printPreviewButton" data-i18n="printButton">打印预览</button>
            </div>
            
            <div class="toolbar-group">
                <label for="langPicker" data-i18n="languageLabel">语言:</label>
                <select id="langPicker">
                    <option value="zh-CN">简体中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            
            <div id="status"></div>
        </div>

        <div class="editor-preview-container">
            <div class="editor-wrapper">
                <div class="section-header" data-i18n="editorHeader">编辑器 (支持 Markdown 和 Mermaid)</div>
                <textarea id="combinedContentInput" data-i18n-placeholder="editorPlaceholder" placeholder="在此输入 Markdown 和 Mermaid 内容..."></textarea>
            </div>
            
            <div class="preview-wrapper">
                <div class="section-header" data-i18n="previewHeader">实时预览</div>
                <div id="documentPreview">
                    <p data-i18n="previewPlaceholder">预览将显示在此处...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 多语言文本定义
        const i18n = {
            'zh-CN': {
                title: 'Markdown & Mermaid to DOCX',
                fontLabel: '字体:',
                chineseFonts: '中文字体',
                englishFonts: '英文字体',
                generateButton: '生成 DOCX',
                printButton: '打印预览',
                languageLabel: '语言:',
                editorHeader: '编辑器 (支持 Markdown 和 Mermaid)',
                editorPlaceholder: '在此输入 Markdown 和 Mermaid 内容...',
                previewHeader: '实时预览',
                previewPlaceholder: '预览将显示在此处...',
                loadingDefault: '正在加载 default.md...',
                defaultLoaded: 'default.md 已加载。',
                defaultLoadError: '无法加载 default.md: ',
                defaultLoadInfo: '(可选) 在项目根目录创建 default.md 文件以自动加载默认内容。',
                generating: '正在生成 DOCX...',
                success: 'DOCX 已生成！',
                error: '生成失败: ',
                printPrompt: '请使用浏览器的打印功能 (Ctrl+P / Cmd+P)',
                viewOnGithub: 'GitHub',
                starButton: '加星'
            },
            'en': {
                title: 'Markdown & Mermaid to DOCX',
                fontLabel: 'Font:',
                chineseFonts: 'Chinese Fonts',
                englishFonts: 'English Fonts',
                generateButton: 'Generate DOCX',
                printButton: 'Print Preview',
                languageLabel: 'Language:',
                editorHeader: 'Editor (Markdown & Mermaid Support)',
                editorPlaceholder: 'Enter Markdown and Mermaid content here...',
                previewHeader: 'Live Preview',
                previewPlaceholder: 'Preview will appear here...',
                loadingDefault: 'Loading default.md...',
                defaultLoaded: 'default.md loaded.',
                defaultLoadError: 'Failed to load default.md: ',
                defaultLoadInfo: '(Optional) Create default.md in the root directory to load default content automatically.',
                generating: 'Generating DOCX...',
                success: 'DOCX generated!',
                error: 'Generation failed: ',
                printPrompt: 'Please use browser print function (Ctrl+P / Cmd+P)',
                viewOnGithub: 'GitHub',
                starButton: 'Star'
            }
        };

        // 当前语言
        let currentLang = localStorage.getItem('preferredLang') || 
                         (navigator.language.startsWith('zh') ? 'zh-CN' : 'en');

        // 应用多语言
        function applyLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('preferredLang', lang);
            
            const texts = i18n[lang];
            
            // 更新所有带 data-i18n 属性的元素
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (texts[key]) {
                    if (el.tagName === 'OPTGROUP') {
                        el.label = texts[key];
                    } else {
                        el.textContent = texts[key];
                    }
                }
            });
            
            // 更新 placeholder
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (texts[key]) {
                    el.placeholder = texts[key];
                }
            });
            
            // 更新语言选择器
            document.getElementById('langPicker').value = lang;
        }

        // 获取翻译文本
        function t(key) {
            return i18n[currentLang][key] || key;
        }

        const combinedContentInput = document.getElementById('combinedContentInput');
        const generateDocxButton = document.getElementById('generateDocxButton');
        const printPreviewButton = document.getElementById('printPreviewButton');
        const statusDiv = document.getElementById('status');
        const documentPreviewDiv = document.getElementById('documentPreview');
        const fontPicker = document.getElementById('fontPicker');
        const langPicker = document.getElementById('langPicker');
        let debounceTimerPreview;
        let isSyncingScroll = false; // 防止循环触发
        let isUpdatingPreview = false; // 防止预览更新时触发同步滚动

        // 初始化语言
        applyLanguage(currentLang);

        // 语言切换事件
        langPicker.addEventListener('change', (e) => {
            applyLanguage(e.target.value);
        });

        mermaid.initialize({
            startOnLoad: false, securityLevel: 'loose',
            flowchart: { htmlLabels: false, useMaxWidth: true }, theme: 'default',
        });

        async function loadDefaultMd() {
            statusDiv.textContent = t('loadingDefault');
            try {
                const response = await fetch('default.md');
                if (!response.ok) throw new Error(`${t('defaultLoadError')}${response.statusText} (Status: ${response.status}). Ensure page is served via HTTP/S.`);
                combinedContentInput.value = await response.text();
                statusDiv.textContent = t('defaultLoaded');
            } catch (error) {
                console.error("Error loading default.md:", error);
                statusDiv.textContent = `${t('defaultLoadError')}${error.message}. ${t('defaultLoadInfo')}`;
            }
            schedulePreviewUpdate();
        }

        function parseCombinedContentFromTextarea(rawText) {
            const structure = [];
            const parts = rawText.split(/(\n?```(?:mermaid|math)\n[\s\S]*?\n```\n?)/g); // Also look for math blocks for future
            let counter = 0;
            for (const part of parts) {
                if (!part || part.trim() === "") continue;
                const mermaidMatch = part.match(/^\n?```mermaid\n([\s\S]*?)\n```\n?$/);
                // const mathMatch = part.match(/^\n?```math\n([\s\S]*?)\n```\n?$/); // For future math support

                if (mermaidMatch) {
                    structure.push({ type: 'mermaid', content: mermaidMatch[1].trim(), id: `mermaid-${counter++}` });
                // } else if (mathMatch) {
                //     structure.push({ type: 'math', content: mathMatch[1].trim(), id: `math-${counter++}` });
                } else if (part.trim()) {
                    structure.push({ type: 'markdown', content: part }); // Keep original spacing for markdown
                }
            }
            return structure;
        }

        // 同步滚动函数
        function syncScroll(source, target) {
            // 如果正在同步滚动或正在更新预览，则不执行
            if (isSyncingScroll || isUpdatingPreview) return;
            isSyncingScroll = true;

            const sourceScrollPercentage = source.scrollTop / (source.scrollHeight - source.clientHeight);
            const targetScrollTop = sourceScrollPercentage * (target.scrollHeight - target.clientHeight);
            target.scrollTop = targetScrollTop;

            setTimeout(() => {
                isSyncingScroll = false;
            }, 50);
        }

        // 为输入框和预览区域添加滚动事件监听
        combinedContentInput.addEventListener('scroll', () => {
            // 只有用户主动滚动编辑器时才同步到预览
            if (!isUpdatingPreview) {
                syncScroll(combinedContentInput, documentPreviewDiv);
            }
        });

        documentPreviewDiv.addEventListener('scroll', () => {
            // 只有用户主动滚动预览时才同步到编辑器
            if (!isUpdatingPreview) {
                syncScroll(documentPreviewDiv, combinedContentInput);
            }
        });

        function schedulePreviewUpdate() {
            clearTimeout(debounceTimerPreview);
            debounceTimerPreview = setTimeout(updateFullPreview, 500);
        }

        async function updateFullPreview() {
            // 标记正在更新预览，防止触发同步滚动
            isUpdatingPreview = true;
            
            // 保存编辑器当前的滚动位置
            const editorScrollTop = combinedContentInput.scrollTop;
            const editorScrollHeight = combinedContentInput.scrollHeight;
            const editorClientHeight = combinedContentInput.clientHeight;
            const editorScrollPercentage = editorScrollTop / (editorScrollHeight - editorClientHeight);
            
            statusDiv.textContent = t('loadingDefault');
            documentPreviewDiv.innerHTML = '';
            let selectedFontFamily = fontPicker.value;
            if (selectedFontFamily === 'Aptos') selectedFontFamily = 'Aptos, Calibri, sans-serif';
            documentPreviewDiv.style.fontFamily = selectedFontFamily;

            const rawContent = combinedContentInput.value;
            const documentStructure = parseCombinedContentFromTextarea(rawContent);
            const markedOptions = { gfm: true, breaks: true,mangle: false, headerIds: false }; // breaks: true for line breaks like in GitHub

            for (const segment of documentStructure) {
                if (segment.type === 'markdown') {
                    const previewSegmentDiv = document.createElement('div');
                    previewSegmentDiv.className = 'markdown-preview-segment';
                    previewSegmentDiv.innerHTML = marked.parse(segment.content, markedOptions);
                    documentPreviewDiv.appendChild(previewSegmentDiv);
                } else if (segment.type === 'mermaid' && segment.id) {
                    const container = document.createElement('div');
                    container.className = 'mermaid-preview-segment';
                    container.id = `preview-${segment.id}`;
                    documentPreviewDiv.appendChild(container);
                    if (segment.content.trim()) {
                        try {
                            const renderId = `previewSvg-${segment.id}-${Date.now()}${Math.random().toString(16).slice(2)}`;
                            const { svg } = await mermaid.render(renderId, segment.content);
                            container.innerHTML = svg;
                        } catch (e) { container.innerHTML = `<div class="error-message">Preview Error: ${e.str || e.message}</div>`; }
                    } else { container.innerHTML = `<p><i>Empty Mermaid diagram (ID: ${segment.id})</i></p>`; }
                }
            }
            if (!documentStructure.length && rawContent.trim() === "") documentPreviewDiv.innerHTML = `<p><i>${t('previewPlaceholder')}</i></p>`;
            statusDiv.textContent = '';
            
            // 延迟恢复同步滚动，等待 DOM 更新完成
            setTimeout(() => {
                // 恢复编辑器的滚动位置（基于之前的百分比）
                const newEditorScrollHeight = combinedContentInput.scrollHeight;
                const newEditorClientHeight = combinedContentInput.clientHeight;
                if (!isNaN(editorScrollPercentage) && isFinite(editorScrollPercentage)) {
                    combinedContentInput.scrollTop = editorScrollPercentage * (newEditorScrollHeight - newEditorClientHeight);
                }
                
                // 预览区域同步到编辑器位置
                if (!isNaN(editorScrollPercentage) && isFinite(editorScrollPercentage)) {
                    const previewScrollHeight = documentPreviewDiv.scrollHeight;
                    const previewClientHeight = documentPreviewDiv.clientHeight;
                    documentPreviewDiv.scrollTop = editorScrollPercentage * (previewScrollHeight - previewClientHeight);
                }
                
                // 恢复同步滚动
                isUpdatingPreview = false;
            }, 100);
        }

        combinedContentInput.addEventListener('input', schedulePreviewUpdate);
        fontPicker.addEventListener('change', schedulePreviewUpdate);
        document.addEventListener('DOMContentLoaded', loadDefaultMd);
        printPreviewButton.addEventListener('click', () => window.print());

        async function renderMermaidToPng(mermaidDefinition, diagramId) {
            if (!mermaidDefinition.trim()) return null;
            try {
                const { svg } = await mermaid.render(`pngSvg-${diagramId}-${Date.now()}`, mermaidDefinition);
                if (!svg) throw new Error("Mermaid.render failed: no SVG string.");
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svg, "image/svg+xml");
                const svgElement = svgDoc.documentElement;
                if (svgElement.tagName === "parsererror" || !svgElement || svgElement.querySelector("parsererror")) throw new Error("Failed to parse SVG.");

                svgElement.style.backgroundColor = "white";
                svgElement.querySelectorAll("tspan, text").forEach(t => t.removeAttribute("xml:space"));
                const cleanedSvgString = new XMLSerializer().serializeToString(svgElement);

                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    img.onload = () => {
                        let svgW = parseFloat(svgElement.getAttribute('width')) || img.naturalWidth || 600;
                        let svgH = parseFloat(svgElement.getAttribute('height')) || img.naturalHeight || 400;
                        const viewBox = svgElement.getAttribute('viewBox');
                        if (viewBox) { const parts = viewBox.split(/[\s,]+/); if (parts.length === 4) { svgW = parseFloat(parts[2]) || svgW; svgH = parseFloat(parts[3]) || svgH; }}
                        if (svgW <= 0 || svgH <= 0) { reject(new Error(`Invalid SVG dimensions for ${diagramId}`)); return; }

                        const scale = 1.5;
                        canvas.width = Math.max(1, Math.round(svgW * scale));
                        canvas.height = Math.max(1, Math.round(svgH * scale));
                        ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                        if(scale !== 1.0) ctx.scale(scale, scale);
                        ctx.drawImage(img, 0, 0, svgW, svgH);
                        canvas.toBlob(blob => blob ? resolve(blob) : reject(new Error("Canvas toBlob failed.")), 'image/png');
                    };
                    img.onerror = () => reject(new Error("Failed to load SVG Data URL into image."));
                    img.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(cleanedSvgString)));
                });
            } catch (e) { console.error(`Error in renderMermaidToPng for ${diagramId}:`, e); statusDiv.textContent = `Error PNG ${diagramId}: ${e.message}`; return null; }
        }

        function processInlineFormatting(parentNode, docxGlobal, options = {}) {
            const runs = [];
            const selectedFont = fontPicker.value;

            Array.from(parentNode.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    runs.push(new docxGlobal.TextRun({ text: child.textContent, ...options }));
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    let currentOptions = { ...options }; // Inherit options from parent
                    const tagName = child.tagName.toLowerCase();

                    if (['ul', 'ol', 'table', 'thead', 'tbody', 'tr', 'th', 'td'].includes(tagName)) return; // Handled by block parser

                    switch (tagName) {
                        case 'strong': case 'b': currentOptions.bold = true; break;
                        case 'em': case 'i': currentOptions.italics = true; break;
                        case 'u': currentOptions.underline = {}; break;
                        case 'br': runs.push(new docxGlobal.TextRun({ break: 1, ...options })); return;
                        case 'del': case 's': currentOptions.strike = true; break;
                        case 'code': // Inline code
                            currentOptions.font = { name: "Courier New" }; // Monospace font
                            currentOptions.size = 20; // 10pt size
                            currentOptions.shading = { type: docxGlobal.ShadingType.SOLID, color: "auto", fill: "F0F0F0" }; // Light gray background
                            break;
                        case 'a': // Links
                            const href = child.getAttribute('href');
                            if (href) {
                                // Recursively process children of <a> to get TextRuns for the link text
                                const linkTextRuns = processInlineFormatting(child, docxGlobal, { ...currentOptions, style: "Hyperlink" }); // Apply Hyperlink style
                                linkTextRuns.forEach(run => {
                                    // The Hyperlink object itself will contain these runs.
                                    // For ExternalHyperlink, children should be TextRun[]
                                });
                                runs.push(new docxGlobal.ExternalHyperlink({
                                    children: linkTextRuns,
                                    link: href,
                                }));
                            }
                            return; // Handled link, stop further processing of this node here
                    }
                    // Recursively process children with current options
                    runs.push(...processInlineFormatting(child, docxGlobal, currentOptions));
                }
            });
            return runs;
        }

        function parseMarkdownToDocxElements(markdownText, docxGlobal) {
            const elements = [];
            // GFM tables, strikethrough, task lists. breaks: true for GFM line breaks (2 spaces at end of line)
            const markedOptions = { gfm: true, breaks: true, mangle: false, headerIds: false };
            const html = marked.parse(markdownText, markedOptions);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            const selectedFont = fontPicker.value;

            const getListLevel = (elementNode) => { /* ... same ... */  let l=0; let c=elementNode.parentElement; while(c&&c!==tempDiv){if(c.tagName==='UL'||c.tagName==='OL')l++; c=c.parentElement;} return Math.max(0,l);};

            const processNode = (node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    let paragraphOptions = { style: "Normal" }; // Default to Normal style for paragraphs

                    switch (tagName) {
                        case 'h1': paragraphOptions = { heading: docxGlobal.HeadingLevel.HEADING_1 }; break;
                        case 'h2': paragraphOptions = { heading: docxGlobal.HeadingLevel.HEADING_2 }; break;
                        case 'h3': paragraphOptions = { heading: docxGlobal.HeadingLevel.HEADING_3 }; break;
                        case 'h4': paragraphOptions = { heading: docxGlobal.HeadingLevel.HEADING_4 }; break;
                        case 'h5': paragraphOptions = { heading: docxGlobal.HeadingLevel.HEADING_5 }; break;
                        case 'h6': paragraphOptions = { heading: docxGlobal.HeadingLevel.HEADING_6 }; break;
                        case 'p': break; // Will use default paragraphOptions ("Normal")
                        case 'blockquote': paragraphOptions = { style: "IntenseQuote" }; break;
                        case 'hr': elements.push(new docxGlobal.Paragraph({ thematicBreak: true })); return;
                        case 'pre':
                            const codeElement = node.querySelector('code');
                            const codeText = codeElement ? codeElement.textContent : node.textContent;
                            // Split by lines and create a paragraph for each to preserve line breaks
                            codeText.split('\n').forEach(line => {
                                elements.push(new docxGlobal.Paragraph({
                                    children: [new docxGlobal.TextRun({ text: line })], // Font & size from style
                                    style: "SourceCode"
                                }));
                            });
                            return;
                        case 'ul': case 'ol':
                            Array.from(node.children).forEach(li => {
                                if (li.tagName.toLowerCase() === 'li') {
                                    const level = getListLevel(li);
                                    // Handle task list items (GFM extension for marked.js)
                                    const isTaskItem = li.classList.contains("task-list-item");
                                    const isChecked = isTaskItem && li.querySelector("input[type='checkbox']").checked;

                                    let prefix = "";
                                    if (isTaskItem) { prefix = isChecked ? "☑ " : "☐ "; }

                                    const contentDiv = document.createElement('div');
                                    Array.from(li.childNodes).forEach(childNode => {
                                        if (childNode.nodeType === Node.ELEMENT_NODE && childNode.tagName === 'INPUT' && childNode.type === 'checkbox') return;
                                        if (childNode.nodeType === Node.ELEMENT_NODE && (childNode.tagName === 'UL' || childNode.tagName === 'OL')) return;
                                        contentDiv.appendChild(childNode.cloneNode(true));
                                    });

                                    let textRuns = processInlineFormatting(contentDiv, docxGlobal);
                                    if (prefix) {
                                        textRuns.unshift(new docxGlobal.TextRun({ text: prefix, font: { name: selectedFont }, size: 20 }));
                                    }

                                    elements.push(new docxGlobal.Paragraph({
                                        children: textRuns,
                                        bullet: tagName === 'ul' && !isTaskItem ? { level: level } : undefined, // No bullet for task items if prefix is used
                                        numbering: tagName === 'ol' ? { reference: "default-numbering", level: level } : undefined
                                    }));
                                    Array.from(li.children).forEach(childNodeInLi => {
                                        if (childNodeInLi.tagName.toLowerCase() === 'ul' || childNodeInLi.tagName.toLowerCase() === 'ol') {
                                            processNode(childNodeInLi);
                                        }
                                    });
                                }
                            });
                            return;
                        case 'table':
                            const rows = [];
                            Array.from(node.querySelectorAll('tr')).forEach(trElement => {
                                const cells = [];
                                Array.from(trElement.querySelectorAll('th, td')).forEach(cellElement => {
                                    const cellContentDiv = document.createElement('div');
                                    // Preserve inline elements within table cells
                                    Array.from(cellElement.childNodes).forEach(child => cellContentDiv.appendChild(child.cloneNode(true)));

                                    cells.push(new docxGlobal.TableCell({
                                        children: [new docxGlobal.Paragraph({ children: processInlineFormatting(cellContentDiv, docxGlobal) })],
                                        borders: { // Add default borders to table cells
                                            top: { style: docxGlobal.BorderStyle.SINGLE, size: 1, color: "auto" },
                                            bottom: { style: docxGlobal.BorderStyle.SINGLE, size: 1, color: "auto" },
                                            left: { style: docxGlobal.BorderStyle.SINGLE, size: 1, color: "auto" },
                                            right: { style: docxGlobal.BorderStyle.SINGLE, size: 1, color: "auto" },
                                        },
                                        // Vertical align can be set here if needed: verticalAlign: docx.VerticalAlign.TOP
                                    }));
                                });
                                rows.push(new docxGlobal.TableRow({ children: cells }));
                            });
                            if (rows.length > 0) {
                                elements.push(new docxGlobal.Table({
                                    rows: rows,
                                    width: { size: 100, type: docxGlobal.WidthType.PERCENTAGE } // Make table full width
                                }));
                            }
                            return;
                        default: // For unhandled block elements or raw HTML (like the <p style="color:red">)
                             if (node.textContent.trim()) { // Process its text content as a normal paragraph
                                paragraphOptions = { style: "Normal" };
                             } else return;
                    }
                    // Common processing for text-based block elements (h1-h6, p, blockquote default)
                    elements.push(new docxGlobal.Paragraph({
                        children: processInlineFormatting(node, docxGlobal),
                        ...paragraphOptions
                    }));

                } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                    // This should ideally be caught by a parent element's processing of inline content
                    elements.push(new docxGlobal.Paragraph({ children: [new docxGlobal.TextRun(node.textContent.trim())], style: "Normal" }));
                }
            };
            Array.from(tempDiv.childNodes).forEach(processNode);
            return elements;
        }

        generateDocxButton.addEventListener('click', async () => {
            generateDocxButton.disabled = true;
            statusDiv.textContent = t('generating');
            const selectedFont = fontPicker.value;
            const docxGlobal = window.docx;
            if (!docxGlobal) { statusDiv.textContent = t('error') + 'DOCX library not loaded.'; generateDocxButton.disabled = false; return; }

            try {
                const finalDocChildren = [];
                const documentStructure = parseCombinedContentFromTextarea(combinedContentInput.value);

                for (const segment of documentStructure) {
                    if (segment.type === 'markdown' && segment.content.trim()) {
                        const markdownElements = parseMarkdownToDocxElements(segment.content, docxGlobal);
                        finalDocChildren.push(...markdownElements);
                    } else if (segment.type === 'mermaid' && segment.id) {
                        statusDiv.textContent = `${t('generating')} Mermaid ${segment.id}...`;
                        const pngBlob = await renderMermaidToPng(segment.content, segment.id);
                        if (pngBlob) {
                            const imageBuffer = await pngBlob.arrayBuffer();
                            const tempImg = new Image(); tempImg.src = URL.createObjectURL(pngBlob);
                            await new Promise(r => tempImg.onload=r); URL.revokeObjectURL(tempImg.src);
                            if (tempImg.naturalWidth > 0 && tempImg.naturalHeight > 0) {
                                finalDocChildren.push(new docxGlobal.Paragraph({
                                    children: [new docxGlobal.ImageRun({ data: imageBuffer, transformation: { width: tempImg.naturalWidth, height: tempImg.naturalHeight }, type:"png", fileName: `${segment.id}.png` })],
                                    alignment: docxGlobal.AlignmentType.CENTER, spacing: { before: 200, after: 200 }
                                }));
                            } else { finalDocChildren.push(new docxGlobal.Paragraph({children: [new docxGlobal.TextRun({text: `[Mermaid image ${segment.id} invalid dimensions]`, italics: true})]}))}
                        } else { finalDocChildren.push(new docxGlobal.Paragraph({children: [new docxGlobal.TextRun({text: `[Mermaid image ${segment.id} could not generate]`, italics: true})]}))}
                    }
                }

                const documentStyles = {
                    default: {
                        document: { run: { font: selectedFont } }, // Base font for document, size set by Normal style
                        heading1: { run: { font: selectedFont, bold: true, size: 36 } },
                        heading2: { run: { font: selectedFont, bold: true, size: 28 } },
                        heading3: { run: { font: selectedFont, bold: true, size: 24 } },
                        heading4: { run: { font: selectedFont, italics: true, size: 24 } },
                        heading5: { run: { font: selectedFont, bold: true, size: 22 } },
                        heading6: { run: { font: selectedFont, bold: true, size: 20 } },
                    },
                     paragraphStyles: [
                        { id: "Normal", name: "Normal", basedOn: "Normal", next: "Normal", run: { font: selectedFont, size: 20 } }, // 10pt
                        { id: "SourceCode", name: "Source Code", basedOn: "Normal", next: "Normal",
                            run: { font: { name: "Courier New" }, size: 18 }, // Code blocks: 9pt
                            paragraph: { indent: { left: 400 }, spacing: { before: 100, after: 100 }, keepLines: true }, // Keep lines together for code
                        },
                        { id: "IntenseQuote", name: "Intense Quote", basedOn: "Normal", next: "Normal",
                            run: { italics: true, color: "4F81BD", font: { name: selectedFont }, size: 20 }, // Changed color to match Word's default
                            paragraph: { indent: { left: 720, right: 720 }, spacing: { line: 276, rule: docxGlobal.LineRuleType.AUTO } },
                        },
                    ],
                    characterStyles: [ // Define Hyperlink character style
                        { id: "Hyperlink", name: "Hyperlink", basedOn: "DefaultParagraphFont", run: { color: "0563C1", underline: { type: docxGlobal.UnderlineType.SINGLE } } }
                    ]
                };

                const fullDoc = new docxGlobal.Document({
                    creator: "MarkdownMermaidToDocx", styles: documentStyles,
                    sections: [{ properties: { page: { margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 }}},
                        children: finalDocChildren.length > 0 ? finalDocChildren : [new docxGlobal.Paragraph("Document is empty.")]
                    }],
                    numbering: { config: [{ reference: "default-numbering",
                        levels: [
                            { level: 0, format: "decimal", text: "%1.", style: { paragraph: { indent: { left: 720, hanging: 360 }}}, run: { font: selectedFont, size: 20 } },
                            { level: 1, format: "lowerLetter", text: "%2)", style: { paragraph: { indent: { left: 1440, hanging: 360 }}}, run: { font: selectedFont, size: 20 } },
                            { level: 2, format: "lowerRoman", text: "%3.", style: { paragraph: { indent: { left: 2160, hanging: 360 }}}, run: { font: selectedFont, size: 20 } },
                            // Add more levels if needed based on default.md nesting
                            { level: 3, format: "decimal", text: "%4.", style: { paragraph: { indent: { left: 2880, hanging: 360 }}}, run: { font: selectedFont, size: 20 } },
                            { level: 4, format: "lowerLetter", text: "%5)", style: { paragraph: { indent: { left: 3600, hanging: 360 }}}, run: { font: selectedFont, size: 20 } },
                            { level: 5, format: "lowerRoman", text: "%6.", style: { paragraph: { indent: { left: 4320, hanging: 360 }}}, run: { font: selectedFont, size: 20 } },
                        ],
                    }]},
                });
                const blob = await docxGlobal.Packer.toBlob(fullDoc);
                saveAs(blob, "markdown_mermaid_document.docx");
                statusDiv.textContent = t('success');
            } catch (e) { console.error("Error DOCX gen:", e, e.stack); statusDiv.textContent = `${t('error')}${e.message}`; }
            finally { generateDocxButton.disabled = false; }
        });

        printPreviewButton.addEventListener('click', () => {
            statusDiv.textContent = t('printPrompt');
            window.print();
        });
    </script>
</body>
</html>
